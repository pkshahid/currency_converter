// Code generated by protoc-gen-go. DO NOT EDIT.
// source: currency.proto

package currency

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Supported currency codes
type CurrencyCode int32

const (
	CurrencyCode_USD CurrencyCode = 0
	CurrencyCode_EUR CurrencyCode = 1
	CurrencyCode_JPY CurrencyCode = 2
)

var CurrencyCode_name = map[int32]string{
	0: "USD",
	1: "EUR",
	2: "JPY",
}

var CurrencyCode_value = map[string]int32{
	"USD": 0,
	"EUR": 1,
	"JPY": 2,
}

func (x CurrencyCode) String() string {
	return proto.EnumName(CurrencyCode_name, int32(x))
}

func (CurrencyCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d3dc60ed002193ea, []int{0}
}

type ConvertRequest struct {
	FromCurrency         string   `protobuf:"bytes,1,opt,name=from_currency,json=fromCurrency,proto3" json:"from_currency,omitempty"`
	ToCurrency           string   `protobuf:"bytes,2,opt,name=to_currency,json=toCurrency,proto3" json:"to_currency,omitempty"`
	Amount               float32  `protobuf:"fixed32,3,opt,name=amount,proto3" json:"amount,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConvertRequest) Reset()         { *m = ConvertRequest{} }
func (m *ConvertRequest) String() string { return proto.CompactTextString(m) }
func (*ConvertRequest) ProtoMessage()    {}
func (*ConvertRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3dc60ed002193ea, []int{0}
}

func (m *ConvertRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConvertRequest.Unmarshal(m, b)
}
func (m *ConvertRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConvertRequest.Marshal(b, m, deterministic)
}
func (m *ConvertRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConvertRequest.Merge(m, src)
}
func (m *ConvertRequest) XXX_Size() int {
	return xxx_messageInfo_ConvertRequest.Size(m)
}
func (m *ConvertRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ConvertRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ConvertRequest proto.InternalMessageInfo

func (m *ConvertRequest) GetFromCurrency() string {
	fmt.Println(m)
	if m != nil {
		return m.FromCurrency
	}
	return ""
}

func (m *ConvertRequest) GetToCurrency() string {
	if m != nil {
		return m.ToCurrency
	}
	return ""
}

func (m *ConvertRequest) GetAmount() float32 {
	if m != nil {
		return m.Amount
	}
	return 0
}

type ConvertResponse struct {
	ConvertedAmount      float32  `protobuf:"fixed32,1,opt,name=converted_amount,json=convertedAmount,proto3" json:"converted_amount,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConvertResponse) Reset()         { *m = ConvertResponse{} }
func (m *ConvertResponse) String() string { return proto.CompactTextString(m) }
func (*ConvertResponse) ProtoMessage()    {}
func (*ConvertResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3dc60ed002193ea, []int{1}
}

func (m *ConvertResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConvertResponse.Unmarshal(m, b)
}
func (m *ConvertResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConvertResponse.Marshal(b, m, deterministic)
}
func (m *ConvertResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConvertResponse.Merge(m, src)
}
func (m *ConvertResponse) XXX_Size() int {
	return xxx_messageInfo_ConvertResponse.Size(m)
}
func (m *ConvertResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ConvertResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ConvertResponse proto.InternalMessageInfo

func (m *ConvertResponse) GetConvertedAmount() float32 {
	if m != nil {
		return m.ConvertedAmount
	}
	return 0
}

func init() {
	proto.RegisterEnum("currency.CurrencyCode", CurrencyCode_name, CurrencyCode_value)
	proto.RegisterType((*ConvertRequest)(nil), "currency.ConvertRequest")
	proto.RegisterType((*ConvertResponse)(nil), "currency.ConvertResponse")
}

func init() { proto.RegisterFile("currency.proto", fileDescriptor_d3dc60ed002193ea) }

var fileDescriptor_d3dc60ed002193ea = []byte{
	// 219 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0x4b, 0x2e, 0x2d, 0x2a,
	0x4a, 0xcd, 0x4b, 0xae, 0xd4, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0xe2, 0x80, 0xf1, 0x95, 0xf2,
	0xb8, 0xf8, 0x9c, 0xf3, 0xf3, 0xca, 0x52, 0x8b, 0x4a, 0x82, 0x52, 0x0b, 0x4b, 0x53, 0x8b, 0x4b,
	0x84, 0x94, 0xb9, 0x78, 0xd3, 0x8a, 0xf2, 0x73, 0xe3, 0x61, 0x4a, 0x24, 0x18, 0x15, 0x18, 0x35,
	0x38, 0x83, 0x78, 0x40, 0x82, 0xce, 0x50, 0x31, 0x21, 0x79, 0x2e, 0xee, 0x92, 0x7c, 0x84, 0x12,
	0x26, 0xb0, 0x12, 0xae, 0x92, 0x7c, 0xb8, 0x02, 0x31, 0x2e, 0xb6, 0xc4, 0xdc, 0xfc, 0xd2, 0xbc,
	0x12, 0x09, 0x66, 0x05, 0x46, 0x0d, 0xa6, 0x20, 0x28, 0x4f, 0xc9, 0x86, 0x8b, 0x1f, 0x6e, 0x5f,
	0x71, 0x41, 0x7e, 0x5e, 0x71, 0xaa, 0x90, 0x26, 0x97, 0x40, 0x32, 0x44, 0x28, 0x35, 0x25, 0x1e,
	0xaa, 0x89, 0x11, 0xac, 0x89, 0x1f, 0x2e, 0xee, 0x08, 0x16, 0xd6, 0xd2, 0xe4, 0xe2, 0x81, 0xd9,
	0xe0, 0x9c, 0x9f, 0x92, 0x2a, 0xc4, 0xce, 0xc5, 0x1c, 0x1a, 0xec, 0x22, 0xc0, 0x00, 0x62, 0xb8,
	0x86, 0x06, 0x09, 0x30, 0x82, 0x18, 0x5e, 0x01, 0x91, 0x02, 0x4c, 0x46, 0xc1, 0x5c, 0x82, 0x08,
	0xa5, 0x10, 0x53, 0x8a, 0x84, 0xec, 0xb8, 0xd8, 0xa1, 0x1c, 0x21, 0x09, 0x3d, 0x78, 0x98, 0xa0,
	0x06, 0x80, 0x94, 0x24, 0x16, 0x19, 0x88, 0x53, 0x93, 0xd8, 0xc0, 0xc1, 0x67, 0x0c, 0x08, 0x00,
	0x00, 0xff, 0xff, 0x39, 0xc9, 0x0a, 0x35, 0x50, 0x01, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// CurrencyConverterClient is the client API for CurrencyConverter service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CurrencyConverterClient interface {
	Convert(ctx context.Context, in *ConvertRequest, opts ...grpc.CallOption) (*ConvertResponse, error)
}

type currencyConverterClient struct {
	cc *grpc.ClientConn
}

func NewCurrencyConverterClient(cc *grpc.ClientConn) CurrencyConverterClient {
	return &currencyConverterClient{cc}
}

func (c *currencyConverterClient) Convert(ctx context.Context, in *ConvertRequest, opts ...grpc.CallOption) (*ConvertResponse, error) {
	out := new(ConvertResponse)
	err := c.cc.Invoke(ctx, "/currency.CurrencyConverter/Convert", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CurrencyConverterServer is the server API for CurrencyConverter service.
type CurrencyConverterServer interface {
	Convert(context.Context, *ConvertRequest) (*ConvertResponse, error)
}

// UnimplementedCurrencyConverterServer can be embedded to have forward compatible implementations.
type UnimplementedCurrencyConverterServer struct {
}

func (*UnimplementedCurrencyConverterServer) Convert(ctx context.Context, req *ConvertRequest) (*ConvertResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Convert not implemented")
}

func RegisterCurrencyConverterServer(s *grpc.Server, srv CurrencyConverterServer) {
	s.RegisterService(&_CurrencyConverter_serviceDesc, srv)
}

func _CurrencyConverter_Convert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConvertRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CurrencyConverterServer).Convert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/currency.CurrencyConverter/Convert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CurrencyConverterServer).Convert(ctx, req.(*ConvertRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _CurrencyConverter_serviceDesc = grpc.ServiceDesc{
	ServiceName: "currency.CurrencyConverter",
	HandlerType: (*CurrencyConverterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Convert",
			Handler:    _CurrencyConverter_Convert_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "currency.proto",
}
